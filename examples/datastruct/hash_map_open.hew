// Hash Map with Open Addressing
// Two parallel Vecs: keys and values. EMPTY key = -1.

fn hash(key: int, capacity: int) -> int {
    let h = key % capacity;
    if h < 0 {
        h + capacity
    } else {
        h
    }
}

fn make_keys(capacity: int) -> Vec<int> {
    let v: Vec<int> = Vec::new();
    let EMPTY = 0 - 1;
    for i in 0..capacity {
        v.push(EMPTY);
    }
    v
}

fn make_vals(capacity: int) -> Vec<int> {
    let v: Vec<int> = Vec::new();
    for i in 0..capacity {
        v.push(0);
    }
    v
}

fn map_insert(keys: Vec<int>, vals: Vec<int>, key: int, value: int) -> bool {
    let capacity = keys.len();
    let EMPTY = 0 - 1;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let k = keys.get(idx);
        if k == key {
            vals.set(idx, value);
            return true;
        }
        if k == EMPTY {
            keys.set(idx, key);
            vals.set(idx, value);
            return true;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    false
}

fn map_get(keys: Vec<int>, vals: Vec<int>, key: int) -> int {
    let capacity = keys.len();
    let EMPTY = 0 - 1;
    let NOT_FOUND = 0 - 999;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let k = keys.get(idx);
        if k == key {
            return vals.get(idx);
        }
        if k == EMPTY {
            return NOT_FOUND;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    NOT_FOUND
}

fn map_contains_key(keys: Vec<int>, key: int) -> bool {
    let capacity = keys.len();
    let EMPTY = 0 - 1;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let k = keys.get(idx);
        if k == key {
            return true;
        }
        if k == EMPTY {
            return false;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    false
}

fn map_remove(keys: Vec<int>, vals: Vec<int>, key: int) -> bool {
    let capacity = keys.len();
    let EMPTY = 0 - 1;
    let DELETED = 0 - 2;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let k = keys.get(idx);
        if k == key {
            keys.set(idx, DELETED);
            vals.set(idx, 0);
            return true;
        }
        if k == EMPTY {
            return false;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    false
}

fn map_size(keys: Vec<int>) -> int {
    let capacity = keys.len();
    let EMPTY = 0 - 1;
    let DELETED = 0 - 2;
    var count = 0;
    for i in 0..capacity {
        let k = keys.get(i);
        if k != EMPTY {
            if k != DELETED {
                count = count + 1;
            }
        }
    }
    count
}

fn main() {
    var passed = 0;
    var failed = 0;
    let cap = 16;
    let keys = make_keys(cap);
    let vals = make_vals(cap);
    let NOT_FOUND = 0 - 999;

    // Test 1: Insert and get
    let _ = map_insert(keys, vals, 1, 100);
    let _ = map_insert(keys, vals, 2, 200);
    let _ = map_insert(keys, vals, 3, 300);
    let v1 = map_get(keys, vals, 1);
    let v2 = map_get(keys, vals, 2);
    let v3 = map_get(keys, vals, 3);
    if v1 == 100 {
        if v2 == 200 {
            if v3 == 300 {
                println("PASS: insert and get");
                passed = passed + 1;
            } else {
                println("FAIL: insert and get");
                failed = failed + 1;
            }
        } else {
            println("FAIL: insert and get");
            failed = failed + 1;
        }
    } else {
        println("FAIL: insert and get");
        failed = failed + 1;
    }

    // Test 2: Get missing key
    let vm = map_get(keys, vals, 99);
    if vm == NOT_FOUND {
        println("PASS: get missing key");
        passed = passed + 1;
    } else {
        println("FAIL: get missing key");
        failed = failed + 1;
    }

    // Test 3: Contains key
    if map_contains_key(keys, 1) {
        if map_contains_key(keys, 99) {
            println("FAIL: contains_key");
            failed = failed + 1;
        } else {
            println("PASS: contains_key");
            passed = passed + 1;
        }
    } else {
        println("FAIL: contains_key");
        failed = failed + 1;
    }

    // Test 4: Update existing key
    let _ = map_insert(keys, vals, 2, 250);
    let v2b = map_get(keys, vals, 2);
    if v2b == 250 {
        let sz = map_size(keys);
        if sz == 3 {
            println("PASS: update existing");
            passed = passed + 1;
        } else {
            println("FAIL: update existing");
            failed = failed + 1;
        }
    } else {
        println("FAIL: update existing");
        failed = failed + 1;
    }

    // Test 5: Remove
    let _ = map_remove(keys, vals, 2);
    if map_contains_key(keys, 2) {
        println("FAIL: remove");
        failed = failed + 1;
    } else {
        let sz2 = map_size(keys);
        if sz2 == 2 {
            println("PASS: remove");
            passed = passed + 1;
        } else {
            println("FAIL: remove");
            failed = failed + 1;
        }
    }

    // Test 6: Get after remove returns NOT_FOUND
    let vr = map_get(keys, vals, 2);
    if vr == NOT_FOUND {
        println("PASS: get after remove");
        passed = passed + 1;
    } else {
        println("FAIL: get after remove");
        failed = failed + 1;
    }

    // Test 7: Collision handling (keys that hash to same slot)
    let _ = map_insert(keys, vals, 0, 10);
    let _ = map_insert(keys, vals, 16, 20);
    let _ = map_insert(keys, vals, 32, 30);
    let c1 = map_get(keys, vals, 0);
    let c2 = map_get(keys, vals, 16);
    let c3 = map_get(keys, vals, 32);
    if c1 == 10 {
        if c2 == 20 {
            if c3 == 30 {
                println("PASS: collision handling");
                passed = passed + 1;
            } else {
                println("FAIL: collision handling");
                failed = failed + 1;
            }
        } else {
            println("FAIL: collision handling");
            failed = failed + 1;
        }
    } else {
        println("FAIL: collision handling");
        failed = failed + 1;
    }

    // Test 8: Size after all operations
    let sz3 = map_size(keys);
    if sz3 == 5 {
        println("PASS: final size");
        passed = passed + 1;
    } else {
        print("FAIL: final size, got ");
        println(sz3);
        failed = failed + 1;
    }

    // Summary
    println("---");
    print("Passed: ");
    println(passed);
    print("Failed: ");
    println(failed);
    if failed == 0 {
        println("ALL PASS");
    } else {
        println("SOME FAILED");
    }
}
