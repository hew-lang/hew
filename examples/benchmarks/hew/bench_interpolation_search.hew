// Benchmark: Interpolation Search
// Estimates position based on value distribution in uniformly distributed data.

fn interpolation_search(v: Vec<int>, target: int) -> int {
    var lo = 0;
    var hi = v.len() - 1;
    while lo <= hi {
        let lo_val = v.get(lo);
        let hi_val = v.get(hi);
        if lo_val == hi_val {
            if lo_val == target {
                return lo;
            }
            return 0 - 1;
        }
        if target < lo_val {
            return 0 - 1;
        }
        if target > hi_val {
            return 0 - 1;
        }
        let pos = lo + (target - lo_val) * (hi - lo) / (hi_val - lo_val);
        let val = v.get(pos);
        if val == target {
            return pos;
        }
        if val < target {
            lo = pos + 1;
        } else {
            hi = pos - 1;
        }
    }
    return 0 - 1;
}

const ITERS: int = 1000000;

fn main() {
    let v: Vec<int> = Vec::new();
    for i in 0..10000 {
        v.push(i);
    }
    var sum = 0;
    for iter in 0..ITERS {
        sum = sum + interpolation_search(v, 7777);
    }
    println(ITERS);
    println(sum);
}
