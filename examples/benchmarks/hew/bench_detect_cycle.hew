fn build_directed_graph(adj_nodes: Vec<int>, adj_offsets: Vec<int>, n: int) -> int {
    var i = 0;
    while i <= n {
        adj_offsets.push(0);
        i = i + 1;
    }

    var src = 0;
    while src < n {
        let start = adj_offsets.get(src);
        var count = 0;
        var dst = 1;
        while dst <= 3 {
            let neighbor = (src + dst) % n;
            adj_nodes.push(neighbor);
            count = count + 1;
            dst = dst + 1;
        }
        let extra = (src * 7 + 13) % n;
        adj_nodes.push(extra);
        count = count + 1;
        adj_offsets.set(src + 1, start + count);
        src = src + 1;
    }
    return 0;
}

fn detect_cycle(adj_nodes: Vec<int>, adj_offsets: Vec<int>, n: int) -> int {
    let color: Vec<int> = Vec::new();
    let stack: Vec<int> = Vec::new();
    let stack_phase: Vec<int> = Vec::new();
    var i = 0;
    while i < n {
        color.push(0);
        i = i + 1;
    }

    var has_cycle = 0;
    var start = 0;
    while start < n {
        if color.get(start) == 0 {
            stack.push(start);
            stack_phase.push(0);

            while stack.len() > 0 {
                let top = stack.len() - 1;
                let node = stack.get(top);
                let phase = stack_phase.get(top);

                if phase == 0 {
                    color.set(node, 1);
                    stack_phase.set(top, 1);
                    let edge_start = adj_offsets.get(node);
                    let edge_end = adj_offsets.get(node + 1);
                    var e = edge_start;
                    while e < edge_end {
                        let neighbor = adj_nodes.get(e);
                        if color.get(neighbor) == 1 {
                            has_cycle = 1;
                        }
                        if color.get(neighbor) == 0 {
                            stack.push(neighbor);
                            stack_phase.push(0);
                        }
                        e = e + 1;
                    }
                } else {
                    color.set(node, 2);
                    stack.pop();
                    stack_phase.pop();
                }
            }
        }
        start = start + 1;
    }
    return has_cycle;
}

fn main() {
    let n = 50;
    let adj_nodes: Vec<int> = Vec::new();
    let adj_offsets: Vec<int> = Vec::new();
    build_directed_graph(adj_nodes, adj_offsets, n);

    let iters = 200000;
    var checksum = 0;
    var i = 0;
    while i < iters {
        checksum = checksum + detect_cycle(adj_nodes, adj_offsets, n);
        i = i + 1;
    }
    println("bench_detect_cycle");
    println(checksum);
    println(iters);
}
