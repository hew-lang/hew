// Sliding Window Maximum using Vec-based deque
// Finds maximum in each sliding window of size k across an array.
// Uses a deque of indices maintaining decreasing order of values.

// Deque using Vec<int>: [front, back, capacity, data...]
// front points to first element, back points past last element
fn deque_create(capacity: int) -> Vec<int> {
    let d: Vec<int> = Vec::new();
    d.push(0);          // index 0: front
    d.push(0);          // index 1: back
    d.push(capacity);   // index 2: capacity
    for i in 0..capacity {
        d.push(0);
    }
    d
}

fn deque_is_empty(d: Vec<int>) -> bool {
    d.get(0) == d.get(1)
}

fn deque_size(d: Vec<int>) -> int {
    let front = d.get(0);
    let back = d.get(1);
    let cap = d.get(2);
    (back - front + cap) % cap
}

fn deque_push_back(d: Vec<int>, val: int) -> int {
    let back = d.get(1);
    let cap = d.get(2);
    d.set(3 + back, val);
    d.set(1, (back + 1) % cap);
    0
}

fn deque_pop_back(d: Vec<int>) -> int {
    let back = d.get(1);
    let cap = d.get(2);
    let new_back = (back - 1 + cap) % cap;
    d.set(1, new_back);
    d.get(3 + new_back)
}

fn deque_pop_front(d: Vec<int>) -> int {
    let front = d.get(0);
    let cap = d.get(2);
    let val = d.get(3 + front);
    d.set(0, (front + 1) % cap);
    val
}

fn deque_front(d: Vec<int>) -> int {
    let front = d.get(0);
    d.get(3 + front)
}

fn deque_back(d: Vec<int>) -> int {
    let back = d.get(1);
    let cap = d.get(2);
    let idx = (back - 1 + cap) % cap;
    d.get(3 + idx)
}

// Sliding window maximum: for each window of size k, find the max
// Returns Vec<int> with n-k+1 results
fn sliding_window_max(arr: Vec<int>, k: int) -> Vec<int> {
    let n = arr.len();
    let result: Vec<int> = Vec::new();
    let dq = deque_create(n + 1);

    for i in 0..n {
        // Remove elements outside the window from front
        while !deque_is_empty(dq) {
            if deque_front(dq) < i - k + 1 {
                deque_pop_front(dq);
            } else {
                break;
            }
        }
        // Remove elements smaller than current from back
        while !deque_is_empty(dq) {
            if arr.get(deque_back(dq)) <= arr.get(i) {
                deque_pop_back(dq);
            } else {
                break;
            }
        }
        deque_push_back(dq, i);
        // Start recording once first window is complete
        if i >= k - 1 {
            result.push(arr.get(deque_front(dq)));
        }
    }
    result
}

fn main() {
    var passed = 0;
    var failed = 0;

    // Test 1: Basic sliding window max
    // arr = [1, 3, -1, -3, 5, 3, 6, 7], k = 3
    // But no negative literals, use positive values:
    // arr = [1, 3, 2, 0, 5, 3, 6, 7], k = 3
    // Windows: [1,3,2]->3, [3,2,0]->3, [2,0,5]->5, [0,5,3]->5, [5,3,6]->6, [3,6,7]->7
    let arr: Vec<int> = Vec::new();
    arr.push(1);
    arr.push(3);
    arr.push(2);
    arr.push(0);
    arr.push(5);
    arr.push(3);
    arr.push(6);
    arr.push(7);
    let res = sliding_window_max(arr, 3);
    var ok1 = 1;
    if res.len() != 6 { ok1 = 0; }
    if ok1 == 1 {
        if res.get(0) != 3 { ok1 = 0; }
        if res.get(1) != 3 { ok1 = 0; }
        if res.get(2) != 5 { ok1 = 0; }
        if res.get(3) != 5 { ok1 = 0; }
        if res.get(4) != 6 { ok1 = 0; }
        if res.get(5) != 7 { ok1 = 0; }
    }
    if ok1 == 1 {
        println("PASS: basic sliding window");
        passed = passed + 1;
    } else {
        println("FAIL: basic sliding window");
        failed = failed + 1;
    }

    // Test 2: Window size = 1 (each element is its own max)
    let arr2: Vec<int> = Vec::new();
    arr2.push(5);
    arr2.push(2);
    arr2.push(8);
    arr2.push(1);
    let res2 = sliding_window_max(arr2, 1);
    var ok2 = 1;
    if res2.len() != 4 { ok2 = 0; }
    if ok2 == 1 {
        if res2.get(0) != 5 { ok2 = 0; }
        if res2.get(1) != 2 { ok2 = 0; }
        if res2.get(2) != 8 { ok2 = 0; }
        if res2.get(3) != 1 { ok2 = 0; }
    }
    if ok2 == 1 {
        println("PASS: window size 1");
        passed = passed + 1;
    } else {
        println("FAIL: window size 1");
        failed = failed + 1;
    }

    // Test 3: Window size = array length (single result = global max)
    let arr3: Vec<int> = Vec::new();
    arr3.push(3);
    arr3.push(7);
    arr3.push(2);
    arr3.push(9);
    arr3.push(1);
    let res3 = sliding_window_max(arr3, 5);
    if res3.len() == 1 {
        if res3.get(0) == 9 {
            println("PASS: window = array length");
            passed = passed + 1;
        } else {
            println("FAIL: window = array length");
            failed = failed + 1;
        }
    } else {
        println("FAIL: window = array length");
        failed = failed + 1;
    }

    // Test 4: All same elements
    let arr4: Vec<int> = Vec::new();
    arr4.push(4);
    arr4.push(4);
    arr4.push(4);
    arr4.push(4);
    let res4 = sliding_window_max(arr4, 2);
    var ok4 = 1;
    if res4.len() != 3 { ok4 = 0; }
    if ok4 == 1 {
        for i in 0..3 {
            if res4.get(i) != 4 { ok4 = 0; }
        }
    }
    if ok4 == 1 {
        println("PASS: all same elements");
        passed = passed + 1;
    } else {
        println("FAIL: all same elements");
        failed = failed + 1;
    }

    // Test 5: Increasing sequence
    // arr = [1, 2, 3, 4, 5], k=3
    // Windows: [1,2,3]->3, [2,3,4]->4, [3,4,5]->5
    let arr5: Vec<int> = Vec::new();
    arr5.push(1);
    arr5.push(2);
    arr5.push(3);
    arr5.push(4);
    arr5.push(5);
    let res5 = sliding_window_max(arr5, 3);
    var ok5 = 1;
    if res5.len() != 3 { ok5 = 0; }
    if ok5 == 1 {
        if res5.get(0) != 3 { ok5 = 0; }
        if res5.get(1) != 4 { ok5 = 0; }
        if res5.get(2) != 5 { ok5 = 0; }
    }
    if ok5 == 1 {
        println("PASS: increasing sequence");
        passed = passed + 1;
    } else {
        println("FAIL: increasing sequence");
        failed = failed + 1;
    }

    // Test 6: Decreasing sequence
    // arr = [5, 4, 3, 2, 1], k=3
    // Windows: [5,4,3]->5, [4,3,2]->4, [3,2,1]->3
    let arr6: Vec<int> = Vec::new();
    arr6.push(5);
    arr6.push(4);
    arr6.push(3);
    arr6.push(2);
    arr6.push(1);
    let res6 = sliding_window_max(arr6, 3);
    var ok6 = 1;
    if res6.len() != 3 { ok6 = 0; }
    if ok6 == 1 {
        if res6.get(0) != 5 { ok6 = 0; }
        if res6.get(1) != 4 { ok6 = 0; }
        if res6.get(2) != 3 { ok6 = 0; }
    }
    if ok6 == 1 {
        println("PASS: decreasing sequence");
        passed = passed + 1;
    } else {
        println("FAIL: decreasing sequence");
        failed = failed + 1;
    }

    // Test 7: Window size 2
    // arr = [10, 5, 2, 7, 8, 7], k=2
    // Windows: [10,5]->10, [5,2]->5, [2,7]->7, [7,8]->8, [8,7]->8
    let arr7: Vec<int> = Vec::new();
    arr7.push(10);
    arr7.push(5);
    arr7.push(2);
    arr7.push(7);
    arr7.push(8);
    arr7.push(7);
    let res7 = sliding_window_max(arr7, 2);
    var ok7 = 1;
    if res7.len() != 5 { ok7 = 0; }
    if ok7 == 1 {
        if res7.get(0) != 10 { ok7 = 0; }
        if res7.get(1) != 5 { ok7 = 0; }
        if res7.get(2) != 7 { ok7 = 0; }
        if res7.get(3) != 8 { ok7 = 0; }
        if res7.get(4) != 8 { ok7 = 0; }
    }
    if ok7 == 1 {
        println("PASS: window size 2");
        passed = passed + 1;
    } else {
        println("FAIL: window size 2");
        failed = failed + 1;
    }

    // Test 8: Deque operations directly
    let dq = deque_create(8);
    deque_push_back(dq, 10);
    deque_push_back(dq, 20);
    deque_push_back(dq, 30);
    let f = deque_front(dq);
    let b = deque_back(dq);
    if f == 10 {
        if b == 30 {
            if deque_size(dq) == 3 {
                println("PASS: deque basics");
                passed = passed + 1;
            } else {
                println("FAIL: deque basics");
                failed = failed + 1;
            }
        } else {
            println("FAIL: deque basics");
            failed = failed + 1;
        }
    } else {
        println("FAIL: deque basics");
        failed = failed + 1;
    }

    // Summary
    println("---");
    print("Passed: ");
    println(passed);
    print("Failed: ");
    println(failed);
    if failed == 0 {
        println("ALL PASS");
    } else {
        println("SOME FAILED");
    }
}
