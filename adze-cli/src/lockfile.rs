//! `adze.lock` lockfile management.
//!
//! The lockfile records exact resolved versions and checksums for all
//! dependencies, enabling reproducible builds.

use std::fmt;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::manifest::HewManifest;

/// A single locked package entry in `adze.lock`.
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct LockedPackage {
    /// Fully qualified package name (e.g. `ecosystem::db::postgres`).
    pub name: String,
    /// Exact resolved version string.
    pub version: String,
    /// Optional integrity checksum in `sha256:{hex}` format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,
    /// Ed25519 signature of the checksum (`"ed25519:{hex}"`).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
    /// Package source: `"registry"`, `"path"`, or `"local"`.
    #[serde(default = "default_source", skip_serializing_if = "is_default_source")]
    pub source: String,
}

fn default_source() -> String {
    "registry".to_string()
}

fn is_default_source(s: &str) -> bool {
    s == "registry"
}

/// The parsed contents of an `adze.lock` file.
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct LockFile {
    /// Locked package entries (sorted by name when written).
    #[serde(rename = "package", default)]
    pub packages: Vec<LockedPackage>,
}

/// Errors that can occur when reading or writing an `adze.lock` file.
#[derive(Debug)]
pub enum LockError {
    /// An I/O error occurred.
    Io(std::io::Error),
    /// The lockfile contents could not be parsed as valid TOML.
    Parse(toml::de::Error),
    /// The lockfile could not be serialized.
    Serialize(toml::ser::Error),
    /// The lockfile is stale (does not match the manifest).
    Stale,
    /// The lockfile does not exist.
    Missing,
}

impl fmt::Display for LockError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Io(e) => write!(f, "lockfile I/O error: {e}"),
            Self::Parse(e) => write!(f, "invalid lockfile: {e}"),
            Self::Serialize(e) => write!(f, "cannot serialize lockfile: {e}"),
            Self::Stale => write!(f, "lockfile is out of date with hew.toml"),
            Self::Missing => write!(f, "adze.lock not found"),
        }
    }
}

impl std::error::Error for LockError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Io(e) => Some(e),
            Self::Parse(e) => Some(e),
            Self::Serialize(e) => Some(e),
            Self::Stale | Self::Missing => None,
        }
    }
}

impl From<std::io::Error> for LockError {
    fn from(e: std::io::Error) -> Self {
        Self::Io(e)
    }
}

impl From<toml::de::Error> for LockError {
    fn from(e: toml::de::Error) -> Self {
        Self::Parse(e)
    }
}

impl From<toml::ser::Error> for LockError {
    fn from(e: toml::ser::Error) -> Self {
        Self::Serialize(e)
    }
}

const LOCKFILE_HEADER: &str = "# This file is auto-generated by adze. Do not edit manually.\n\n";

/// Read and parse an `adze.lock` file at `path`.
///
/// # Errors
///
/// Returns [`LockError::Missing`] when the file does not exist,
/// [`LockError::Io`] on other I/O failures, or [`LockError::Parse`] when the
/// TOML is malformed.
pub fn read_lockfile(path: &Path) -> Result<LockFile, LockError> {
    if !path.exists() {
        return Err(LockError::Missing);
    }
    let text = std::fs::read_to_string(path)?;
    let lockfile: LockFile = toml::from_str(&text)?;
    Ok(lockfile)
}

/// Write a `LockFile` to `path`, sorting packages by name for determinism.
///
/// # Errors
///
/// Returns [`LockError::Serialize`] if the lockfile cannot be serialized, or
/// [`LockError::Io`] if the file cannot be written.
pub fn write_lockfile(path: &Path, lockfile: &LockFile) -> Result<(), LockError> {
    let mut sorted = lockfile.clone();
    sorted.packages.sort_by(|a, b| a.name.cmp(&b.name));

    let body = toml::to_string(&sorted)?;
    let content = format!("{LOCKFILE_HEADER}{body}");
    std::fs::write(path, content)?;
    Ok(())
}

/// Returns `true` if the lockfile is stale relative to the manifest.
///
/// A lockfile is stale when:
/// - A manifest dependency is not present in the lockfile, or
/// - A lockfile entry has no corresponding manifest dependency.
#[must_use]
pub fn is_lock_stale(lockfile: &LockFile, manifest: &HewManifest) -> bool {
    let locked_names: std::collections::BTreeSet<&str> =
        lockfile.packages.iter().map(|p| p.name.as_str()).collect();
    let manifest_names: std::collections::BTreeSet<&str> =
        manifest.dependencies.keys().map(String::as_str).collect();

    locked_names != manifest_names
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;

    use crate::manifest::{self, Package};

    fn make_manifest(deps: &[(&str, &str)]) -> HewManifest {
        HewManifest {
            package: Package {
                name: "testpkg".to_string(),
                version: "0.1.0".to_string(),
                description: None,
                authors: None,
                license: None,
                keywords: None,
                categories: None,
                homepage: None,
                repository: None,
                documentation: None,
                readme: None,
                exclude: None,
                include: None,
                edition: None,
                hew: None,
            },
            dependencies: deps
                .iter()
                .map(|(k, v)| {
                    (
                        (*k).to_string(),
                        manifest::DepSpec::Version((*v).to_string()),
                    )
                })
                .collect::<BTreeMap<_, _>>(),
            dev_dependencies: BTreeMap::new(),
            features: BTreeMap::new(),
        }
    }

    #[test]
    fn roundtrip_write_read() {
        let dir = tempfile::tempdir().unwrap();
        let lock_path = dir.path().join("adze.lock");

        let lockfile = LockFile {
            packages: vec![
                LockedPackage {
                    name: "std::net::http".to_string(),
                    version: "2.1.0".to_string(),
                    checksum: Some("sha256:def456".to_string()),
                    signature: None,
                    source: "registry".to_string(),
                },
                LockedPackage {
                    name: "ecosystem::db::postgres".to_string(),
                    version: "1.0.0".to_string(),
                    checksum: Some("sha256:abc123".to_string()),
                    signature: None,
                    source: "registry".to_string(),
                },
            ],
        };

        write_lockfile(&lock_path, &lockfile).unwrap();
        let read_back = read_lockfile(&lock_path).unwrap();

        // Should be sorted by name after write.
        assert_eq!(read_back.packages.len(), 2);
        assert_eq!(read_back.packages[0].name, "ecosystem::db::postgres");
        assert_eq!(read_back.packages[1].name, "std::net::http");
        assert_eq!(
            read_back.packages[0].checksum.as_deref(),
            Some("sha256:abc123")
        );
    }

    #[test]
    fn roundtrip_without_checksum() {
        let dir = tempfile::tempdir().unwrap();
        let lock_path = dir.path().join("adze.lock");

        let lockfile = LockFile {
            packages: vec![LockedPackage {
                name: "mypkg".to_string(),
                version: "0.1.0".to_string(),
                checksum: None,
                signature: None,
                source: "registry".to_string(),
            }],
        };

        write_lockfile(&lock_path, &lockfile).unwrap();
        let read_back = read_lockfile(&lock_path).unwrap();

        assert_eq!(read_back.packages.len(), 1);
        assert!(read_back.packages[0].checksum.is_none());
    }

    #[test]
    fn empty_lockfile_roundtrip() {
        let dir = tempfile::tempdir().unwrap();
        let lock_path = dir.path().join("adze.lock");

        let lockfile = LockFile {
            packages: Vec::new(),
        };

        write_lockfile(&lock_path, &lockfile).unwrap();
        let read_back = read_lockfile(&lock_path).unwrap();

        assert!(read_back.packages.is_empty());
    }

    #[test]
    fn read_missing_lockfile() {
        let dir = tempfile::tempdir().unwrap();
        let lock_path = dir.path().join("adze.lock");

        let err = read_lockfile(&lock_path).unwrap_err();
        assert!(matches!(err, LockError::Missing));
    }

    #[test]
    fn stale_when_manifest_has_extra_dep() {
        let lockfile = LockFile {
            packages: vec![LockedPackage {
                name: "std::net::http".to_string(),
                version: "1.0.0".to_string(),
                checksum: None,
                signature: None,
                source: "registry".to_string(),
            }],
        };
        let manifest = make_manifest(&[
            ("std::net::http", "1.0"),
            ("ecosystem::db::postgres", "2.0"),
        ]);

        assert!(is_lock_stale(&lockfile, &manifest));
    }

    #[test]
    fn stale_when_lock_has_extra_dep() {
        let lockfile = LockFile {
            packages: vec![
                LockedPackage {
                    name: "std::net::http".to_string(),
                    version: "1.0.0".to_string(),
                    checksum: None,
                    signature: None,
                    source: "registry".to_string(),
                },
                LockedPackage {
                    name: "ecosystem::db::postgres".to_string(),
                    version: "2.0.0".to_string(),
                    checksum: None,
                    signature: None,
                    source: "registry".to_string(),
                },
            ],
        };
        let manifest = make_manifest(&[("std::net::http", "1.0")]);

        assert!(is_lock_stale(&lockfile, &manifest));
    }

    #[test]
    fn not_stale_when_matching() {
        let lockfile = LockFile {
            packages: vec![
                LockedPackage {
                    name: "ecosystem::db::postgres".to_string(),
                    version: "2.0.0".to_string(),
                    checksum: None,
                    signature: None,
                    source: "registry".to_string(),
                },
                LockedPackage {
                    name: "std::net::http".to_string(),
                    version: "1.0.0".to_string(),
                    checksum: None,
                    signature: None,
                    source: "registry".to_string(),
                },
            ],
        };
        let manifest = make_manifest(&[
            ("std::net::http", "^1.0"),
            ("ecosystem::db::postgres", "2.0"),
        ]);

        assert!(!is_lock_stale(&lockfile, &manifest));
    }

    #[test]
    fn not_stale_when_both_empty() {
        let lockfile = LockFile {
            packages: Vec::new(),
        };
        let manifest = make_manifest(&[]);

        assert!(!is_lock_stale(&lockfile, &manifest));
    }

    #[test]
    fn sorted_output_is_deterministic() {
        let dir = tempfile::tempdir().unwrap();
        let lock_path = dir.path().join("adze.lock");

        let lockfile = LockFile {
            packages: vec![
                LockedPackage {
                    name: "zzz::last".to_string(),
                    version: "1.0.0".to_string(),
                    checksum: None,
                    signature: None,
                    source: "registry".to_string(),
                },
                LockedPackage {
                    name: "aaa::first".to_string(),
                    version: "1.0.0".to_string(),
                    checksum: None,
                    signature: None,
                    source: "registry".to_string(),
                },
            ],
        };

        write_lockfile(&lock_path, &lockfile).unwrap();
        let content = std::fs::read_to_string(&lock_path).unwrap();

        let first_pos = content.find("aaa::first").unwrap();
        let last_pos = content.find("zzz::last").unwrap();
        assert!(first_pos < last_pos, "packages should be sorted by name");
    }

    #[test]
    fn header_is_written() {
        let dir = tempfile::tempdir().unwrap();
        let lock_path = dir.path().join("adze.lock");

        let lockfile = LockFile {
            packages: Vec::new(),
        };
        write_lockfile(&lock_path, &lockfile).unwrap();

        let content = std::fs::read_to_string(&lock_path).unwrap();
        assert!(content.starts_with("# This file is auto-generated by adze."));
    }

    #[test]
    fn error_display_coverage() {
        let io_err = LockError::Io(std::io::Error::new(std::io::ErrorKind::Other, "boom"));
        assert!(io_err.to_string().contains("boom"));

        let stale_err = LockError::Stale;
        assert!(stale_err.to_string().contains("out of date"));

        let missing_err = LockError::Missing;
        assert!(missing_err.to_string().contains("not found"));
    }
}
