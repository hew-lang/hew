// Bipartite Check - 2-coloring BFS
// Color 0 = unvisited, 1 = color A, 2 = color B

fn is_bipartite(adj_nodes: Vec<int>, adj_offsets: Vec<int>, num_nodes: int) -> bool {
    let color: Vec<int> = Vec::new();
    for i in 0..num_nodes {
        color.push(0);
    }
    // BFS from each unvisited node (handles disconnected graphs)
    for start in 0..num_nodes {
        if color.get(start) != 0 {
            // already colored
        } else {
            color.set(start, 1);
            let queue: Vec<int> = Vec::new();
            queue.push(start);
            var head = 0;
            while head < queue.len() {
                let node = queue.get(head);
                head = head + 1;
                let my_color = color.get(node);
                var next_color = 1;
                if my_color == 1 {
                    next_color = 2;
                }
                let s = adj_offsets.get(node);
                let e = adj_offsets.get(node + 1);
                var j = s;
                while j < e {
                    let nb = adj_nodes.get(j);
                    if color.get(nb) == 0 {
                        color.set(nb, next_color);
                        queue.push(nb);
                    } else if color.get(nb) == my_color {
                        return false;
                    }
                    j = j + 1;
                }
            }
        }
    }
    true
}

fn build_undirected(num_nodes: int, esrc: Vec<int>, edst: Vec<int>, adj_nodes: Vec<int>, adj_offsets: Vec<int>) {
    let num_edges = esrc.len();
    let degree: Vec<int> = Vec::new();
    for i in 0..num_nodes {
        degree.push(0);
    }
    for i in 0..num_edges {
        let s = esrc.get(i);
        let d = edst.get(i);
        degree.set(s, degree.get(s) + 1);
        degree.set(d, degree.get(d) + 1);
    }
    adj_offsets.push(0);
    for i in 0..num_nodes {
        adj_offsets.push(adj_offsets.get(i) + degree.get(i));
    }
    let total = adj_offsets.get(num_nodes);
    for i in 0..total {
        adj_nodes.push(0);
    }
    let pos: Vec<int> = Vec::new();
    for i in 0..num_nodes {
        pos.push(adj_offsets.get(i));
    }
    for i in 0..num_edges {
        let s = esrc.get(i);
        let d = edst.get(i);
        adj_nodes.set(pos.get(s), d);
        pos.set(s, pos.get(s) + 1);
        adj_nodes.set(pos.get(d), s);
        pos.set(d, pos.get(d) + 1);
    }
}

fn main() {
    var passed = 0;
    var failed = 0;

    // Graph 1: Bipartite (even cycle: 0-1-2-3-0)
    // Partitions: {0,2} and {1,3}
    let n1 = 4;
    let s1: Vec<int> = Vec::new();
    let d1: Vec<int> = Vec::new();
    s1.push(0); d1.push(1);
    s1.push(1); d1.push(2);
    s1.push(2); d1.push(3);
    s1.push(3); d1.push(0);
    let an1: Vec<int> = Vec::new();
    let ao1: Vec<int> = Vec::new();
    build_undirected(n1, s1, d1, an1, ao1);

    // Test 1: 4-cycle is bipartite
    if is_bipartite(an1, ao1, n1) {
        println("PASS: 4-cycle is bipartite");
        passed = passed + 1;
    } else {
        println("FAIL: 4-cycle bipartite");
        failed = failed + 1;
    }

    // Graph 2: Non-bipartite (triangle: 0-1-2-0)
    let n2 = 3;
    let s2: Vec<int> = Vec::new();
    let d2: Vec<int> = Vec::new();
    s2.push(0); d2.push(1);
    s2.push(1); d2.push(2);
    s2.push(2); d2.push(0);
    let an2: Vec<int> = Vec::new();
    let ao2: Vec<int> = Vec::new();
    build_undirected(n2, s2, d2, an2, ao2);

    // Test 2: Triangle is not bipartite
    if is_bipartite(an2, ao2, n2) {
        println("FAIL: triangle should not be bipartite");
        failed = failed + 1;
    } else {
        println("PASS: triangle is not bipartite");
        passed = passed + 1;
    }

    // Graph 3: Bipartite tree: 0-1, 0-2, 1-3, 1-4
    let n3 = 5;
    let s3: Vec<int> = Vec::new();
    let d3: Vec<int> = Vec::new();
    s3.push(0); d3.push(1);
    s3.push(0); d3.push(2);
    s3.push(1); d3.push(3);
    s3.push(1); d3.push(4);
    let an3: Vec<int> = Vec::new();
    let ao3: Vec<int> = Vec::new();
    build_undirected(n3, s3, d3, an3, ao3);

    // Test 3: Tree is always bipartite
    if is_bipartite(an3, ao3, n3) {
        println("PASS: tree is bipartite");
        passed = passed + 1;
    } else {
        println("FAIL: tree bipartite");
        failed = failed + 1;
    }

    // Graph 4: 5-cycle (odd cycle, not bipartite)
    let n4 = 5;
    let s4: Vec<int> = Vec::new();
    let d4: Vec<int> = Vec::new();
    s4.push(0); d4.push(1);
    s4.push(1); d4.push(2);
    s4.push(2); d4.push(3);
    s4.push(3); d4.push(4);
    s4.push(4); d4.push(0);
    let an4: Vec<int> = Vec::new();
    let ao4: Vec<int> = Vec::new();
    build_undirected(n4, s4, d4, an4, ao4);

    // Test 4: 5-cycle is not bipartite
    if is_bipartite(an4, ao4, n4) {
        println("FAIL: 5-cycle should not be bipartite");
        failed = failed + 1;
    } else {
        println("PASS: 5-cycle is not bipartite");
        passed = passed + 1;
    }

    // Graph 5: Single node (trivially bipartite)
    let n5 = 1;
    let s5: Vec<int> = Vec::new();
    let d5: Vec<int> = Vec::new();
    let an5: Vec<int> = Vec::new();
    let ao5: Vec<int> = Vec::new();
    build_undirected(n5, s5, d5, an5, ao5);

    // Test 5: Single node
    if is_bipartite(an5, ao5, n5) {
        println("PASS: single node is bipartite");
        passed = passed + 1;
    } else {
        println("FAIL: single node bipartite");
        failed = failed + 1;
    }

    // Graph 6: Complete bipartite K(2,3): {0,1} x {2,3,4}
    let n6 = 5;
    let s6: Vec<int> = Vec::new();
    let d6: Vec<int> = Vec::new();
    s6.push(0); d6.push(2);
    s6.push(0); d6.push(3);
    s6.push(0); d6.push(4);
    s6.push(1); d6.push(2);
    s6.push(1); d6.push(3);
    s6.push(1); d6.push(4);
    let an6: Vec<int> = Vec::new();
    let ao6: Vec<int> = Vec::new();
    build_undirected(n6, s6, d6, an6, ao6);

    // Test 6: K(2,3) is bipartite
    if is_bipartite(an6, ao6, n6) {
        println("PASS: K(2,3) is bipartite");
        passed = passed + 1;
    } else {
        println("FAIL: K(2,3) bipartite");
        failed = failed + 1;
    }

    // Graph 7: 6-cycle (even, bipartite)
    let n7 = 6;
    let s7: Vec<int> = Vec::new();
    let d7: Vec<int> = Vec::new();
    s7.push(0); d7.push(1);
    s7.push(1); d7.push(2);
    s7.push(2); d7.push(3);
    s7.push(3); d7.push(4);
    s7.push(4); d7.push(5);
    s7.push(5); d7.push(0);
    let an7: Vec<int> = Vec::new();
    let ao7: Vec<int> = Vec::new();
    build_undirected(n7, s7, d7, an7, ao7);

    // Test 7: 6-cycle is bipartite
    if is_bipartite(an7, ao7, n7) {
        println("PASS: 6-cycle is bipartite");
        passed = passed + 1;
    } else {
        println("FAIL: 6-cycle bipartite");
        failed = failed + 1;
    }

    // Graph 8: 6-cycle + chord creating odd cycle (0-1-2-3-4-5-0 + 0-2)
    // The chord 0-2 creates triangle 0-1-2-0 (odd cycle)
    let n8 = 6;
    let s8: Vec<int> = Vec::new();
    let d8: Vec<int> = Vec::new();
    s8.push(0); d8.push(1);
    s8.push(1); d8.push(2);
    s8.push(2); d8.push(3);
    s8.push(3); d8.push(4);
    s8.push(4); d8.push(5);
    s8.push(5); d8.push(0);
    s8.push(0); d8.push(2);
    let an8: Vec<int> = Vec::new();
    let ao8: Vec<int> = Vec::new();
    build_undirected(n8, s8, d8, an8, ao8);

    // Test 8: 6-cycle+chord has odd cycle, not bipartite
    if is_bipartite(an8, ao8, n8) {
        println("FAIL: cycle+chord should not be bipartite");
        failed = failed + 1;
    } else {
        println("PASS: cycle+chord not bipartite");
        passed = passed + 1;
    }

    println("---");
    print("Passed: ");
    print(passed);
    print("/");
    println(8);
    if failed == 0 {
        println("ALL PASS");
    } else {
        println("SOME FAILED");
    }
}
