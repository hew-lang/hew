fn build_graph(adj_nodes: Vec<int>, adj_offsets: Vec<int>, n: int) -> int {
    for i in 0..(n + 1) {
        adj_offsets.push(0);
    }

    for src in 0..n {
        let start = adj_offsets.get(src);
        var count = 0;
        for dst in 1..6 {
            let neighbor = (src + dst) % n;
            adj_nodes.push(neighbor);
            count = count + 1;
        }
        let extra1 = (src * 7 + 3) % n;
        adj_nodes.push(extra1);
        count = count + 1;
        adj_offsets.set(src + 1, start + count);
    }
    return 0;
}

fn dfs(adj_nodes: Vec<int>, adj_offsets: Vec<int>, n: int, start_node: int) -> int {
    let visited: Vec<int> = Vec::new();
    let stack: Vec<int> = Vec::new();
    for i in 0..n {
        visited.push(0);
    }

    stack.push(start_node);
    var count = 0;

    while stack.len() > 0 {
        let node = stack.pop();
        if visited.get(node) == 1 {
            count = count;
        } else {
            visited.set(node, 1);
            count = count + 1;

            for e in adj_offsets.get(node)..adj_offsets.get(node + 1) {
                let neighbor = adj_nodes.get(e);
                if visited.get(neighbor) == 0 {
                    stack.push(neighbor);
                }
            }
        }
    }
    return count;
}

const ITERS: int = 100000;

fn main() {
    let n = 50;
    let adj_nodes: Vec<int> = Vec::new();
    let adj_offsets: Vec<int> = Vec::new();
    let _ = build_graph(adj_nodes, adj_offsets, n);

    var checksum = 0;
    for i in 0..ITERS {
        checksum = checksum + dfs(adj_nodes, adj_offsets, n, 0);
    }
    println("bench_dfs");
    println(checksum);
    println(ITERS);
}
