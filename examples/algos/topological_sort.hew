// Topological Sort using Kahn's Algorithm (in-degree based)
// DAG (6 nodes):
//   0->2, 0->3, 1->3, 1->4, 2->5, 3->5, 4->5
// Valid orderings have all edges going forward

fn main() {
    let num_nodes = 6;

    // Build adjacency list (directed)
    let adj_nodes: Vec<i32> = Vec::new();
    let adj_offsets: Vec<i32> = Vec::new();

    // Node 0: -> 2, 3
    adj_offsets.push(0);
    adj_nodes.push(2);
    adj_nodes.push(3);
    // Node 1: -> 3, 4
    adj_offsets.push(2);
    adj_nodes.push(3);
    adj_nodes.push(4);
    // Node 2: -> 5
    adj_offsets.push(4);
    adj_nodes.push(5);
    // Node 3: -> 5
    adj_offsets.push(5);
    adj_nodes.push(5);
    // Node 4: -> 5
    adj_offsets.push(6);
    adj_nodes.push(5);
    // Node 5: (no outgoing)
    adj_offsets.push(7);
    adj_offsets.push(7);

    // Compute in-degrees
    let in_degree: Vec<i32> = Vec::new();
    for i in 0..num_nodes {
        in_degree.push(0);
    }
    for i in 0..num_nodes {
        let start = adj_offsets.get(i);
        let end = adj_offsets.get(i + 1);
        var idx = start;
        while idx < end {
            let v = adj_nodes.get(idx);
            in_degree.set(v, in_degree.get(v) + 1);
            idx = idx + 1;
        }
    }

    // Kahn's: start with in-degree 0 nodes
    let queue: Vec<i32> = Vec::new();
    for i in 0..num_nodes {
        if in_degree.get(i) == 0 {
            queue.push(i);
        }
    }

    let result: Vec<i32> = Vec::new();
    var front = 0;
    while front < queue.len() {
        let u = queue.get(front);
        front = front + 1;
        result.push(u);

        let start = adj_offsets.get(u);
        let end = adj_offsets.get(u + 1);
        var idx = start;
        while idx < end {
            let v = adj_nodes.get(idx);
            in_degree.set(v, in_degree.get(v) - 1);
            if in_degree.get(v) == 0 {
                queue.push(v);
            }
            idx = idx + 1;
        }
    }

    // Print result
    for i in 0..result.len() {
        println(result.get(i));
    }

    // Verify: all 6 nodes present and edges go forward
    var valid = 1;
    if result.len() != 6 {
        valid = 0;
    }

    // Build position map
    let pos: Vec<i32> = Vec::new();
    for i in 0..num_nodes {
        pos.push(0);
    }
    for i in 0..result.len() {
        pos.set(result.get(i), i);
    }

    // Check all edges go forward
    for i in 0..num_nodes {
        let start = adj_offsets.get(i);
        let end = adj_offsets.get(i + 1);
        var idx = start;
        while idx < end {
            let v = adj_nodes.get(idx);
            if pos.get(i) >= pos.get(v) {
                valid = 0;
            }
            idx = idx + 1;
        }
    }

    if valid == 1 {
        println("PASS");
    } else {
        println("FAIL");
    }
}
