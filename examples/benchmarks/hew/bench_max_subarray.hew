fn max_subarray(arr: Vec<int>) -> int {
    let n = arr.len();
    var max_ending = arr.get(0);
    var max_so_far = arr.get(0);
    for i in 1..n {
        let val = arr.get(i);
        if val > max_ending + val {
            max_ending = val;
        } else {
            max_ending = max_ending + val;
        }
        if max_ending > max_so_far {
            max_so_far = max_ending;
        }
    }
    return max_so_far;
}

const ITERS: int = 500000;

fn main() {
    let arr: Vec<int> = Vec::new();
    for k in 0..1000 {
        let rem = k % 3;
        if rem == 0 {
            arr.push(k % 7 + 1);
        } else {
            if rem == 1 {
                arr.push(0 - (k % 5 + 1));
            } else {
                arr.push(k % 10);
            }
        }
    }

    var checksum = 0;
    for i in 0..ITERS {
        checksum = checksum + max_subarray(arr);
    }
    println("bench_max_subarray");
    println(checksum);
    println(ITERS);
}
