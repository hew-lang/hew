// Hash Set with Open Addressing (Linear Probing)
// Uses Vec<int> with EMPTY=-1, DELETED=-2 sentinels

fn hash(key: int, capacity: int) -> int {
    let h = key % capacity;
    if h < 0 {
        h + capacity
    } else {
        h
    }
}

fn make_set(capacity: int) -> Vec<int> {
    let v: Vec<int> = Vec::new();
    let EMPTY = 0 - 1;
    for i in 0..capacity {
        v.push(EMPTY);
    }
    v
}

fn set_insert(set: Vec<int>, key: int) -> bool {
    let capacity = set.len();
    let EMPTY = 0 - 1;
    let DELETED = 0 - 2;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let val = set.get(idx);
        if val == key {
            return false;
        }
        if val == EMPTY {
            set.set(idx, key);
            return true;
        }
        if val == DELETED {
            set.set(idx, key);
            return true;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    false
}

fn set_contains(set: Vec<int>, key: int) -> bool {
    let capacity = set.len();
    let EMPTY = 0 - 1;
    let DELETED = 0 - 2;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let val = set.get(idx);
        if val == key {
            return true;
        }
        if val == EMPTY {
            return false;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    false
}

fn set_remove(set: Vec<int>, key: int) -> bool {
    let capacity = set.len();
    let EMPTY = 0 - 1;
    let DELETED = 0 - 2;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let val = set.get(idx);
        if val == key {
            set.set(idx, DELETED);
            return true;
        }
        if val == EMPTY {
            return false;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    false
}

fn set_size(set: Vec<int>) -> int {
    let capacity = set.len();
    let EMPTY = 0 - 1;
    let DELETED = 0 - 2;
    var count = 0;
    for i in 0..capacity {
        let val = set.get(i);
        if val != EMPTY {
            if val != DELETED {
                count = count + 1;
            }
        }
    }
    count
}

fn main() {
    var passed = 0;
    var failed = 0;
    let set = make_set(16);

    // Test 1: Insert and contains
    set_insert(set, 5);
    set_insert(set, 10);
    set_insert(set, 15);
    if set_contains(set, 5) {
        if set_contains(set, 10) {
            if set_contains(set, 15) {
                println("PASS: insert and contains");
                passed = passed + 1;
            } else {
                println("FAIL: insert and contains");
                failed = failed + 1;
            }
        } else {
            println("FAIL: insert and contains");
            failed = failed + 1;
        }
    } else {
        println("FAIL: insert and contains");
        failed = failed + 1;
    }

    // Test 2: Contains returns false for missing keys
    if set_contains(set, 99) {
        println("FAIL: missing key");
        failed = failed + 1;
    } else {
        if set_contains(set, 0) {
            println("FAIL: missing key");
            failed = failed + 1;
        } else {
            println("PASS: missing key");
            passed = passed + 1;
        }
    }

    // Test 3: Size
    let sz = set_size(set);
    if sz == 3 {
        println("PASS: size");
        passed = passed + 1;
    } else {
        println("FAIL: size");
        failed = failed + 1;
    }

    // Test 4: Duplicate insert
    let dup = set_insert(set, 5);
    if dup {
        println("FAIL: duplicate insert");
        failed = failed + 1;
    } else {
        let sz2 = set_size(set);
        if sz2 == 3 {
            println("PASS: duplicate insert");
            passed = passed + 1;
        } else {
            println("FAIL: duplicate insert");
            failed = failed + 1;
        }
    }

    // Test 5: Remove
    let removed = set_remove(set, 10);
    if removed {
        if set_contains(set, 10) {
            println("FAIL: remove");
            failed = failed + 1;
        } else {
            let sz3 = set_size(set);
            if sz3 == 2 {
                println("PASS: remove");
                passed = passed + 1;
            } else {
                println("FAIL: remove");
                failed = failed + 1;
            }
        }
    } else {
        println("FAIL: remove");
        failed = failed + 1;
    }

    // Test 6: Contains still works after remove (probing past deleted)
    if set_contains(set, 15) {
        if set_contains(set, 5) {
            println("PASS: contains after remove");
            passed = passed + 1;
        } else {
            println("FAIL: contains after remove");
            failed = failed + 1;
        }
    } else {
        println("FAIL: contains after remove");
        failed = failed + 1;
    }

    // Test 7: Remove non-existent
    let rem2 = set_remove(set, 99);
    if rem2 {
        println("FAIL: remove non-existent");
        failed = failed + 1;
    } else {
        println("PASS: remove non-existent");
        passed = passed + 1;
    }

    // Test 8: Re-insert after remove
    set_insert(set, 10);
    if set_contains(set, 10) {
        let sz4 = set_size(set);
        if sz4 == 3 {
            println("PASS: re-insert after remove");
            passed = passed + 1;
        } else {
            println("FAIL: re-insert after remove");
            failed = failed + 1;
        }
    } else {
        println("FAIL: re-insert after remove");
        failed = failed + 1;
    }

    // Summary
    println("---");
    print("Passed: ");
    println(passed);
    print("Failed: ");
    println(failed);
    if failed == 0 {
        println("ALL PASS");
    } else {
        println("SOME FAILED");
    }
}
