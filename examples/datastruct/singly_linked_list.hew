// Singly Linked List using Vec<i32> with index-based pointers
// Node layout: nodes[i*2] = value, nodes[i*2+1] = next
// NIL sentinel = -1

fn node_val(nodes: Vec<i32>, idx: i32) -> i32 { nodes.get(idx * 2) }
fn node_next(nodes: Vec<i32>, idx: i32) -> i32 { nodes.get(idx * 2 + 1) }
fn set_next(nodes: Vec<i32>, idx: i32, nxt: i32) { nodes.set(idx * 2 + 1, nxt); }

fn alloc_node(nodes: Vec<i32>, val: i32) -> i32 {
    let idx = nodes.len() / 2;
    nodes.push(val);
    nodes.push(-1);
    idx
}

// Prepend: returns new head
fn prepend(nodes: Vec<i32>, head: i32, val: i32) -> i32 {
    let n = alloc_node(nodes, val);
    set_next(nodes, n, head);
    n
}

// Append: returns head (may change if list was empty)
fn append(nodes: Vec<i32>, head: i32, val: i32) -> i32 {
    let n = alloc_node(nodes, val);
    if head == -1 {
        return n;
    }
    var curr = head;
    while node_next(nodes, curr) != -1 {
        curr = node_next(nodes, curr);
    }
    set_next(nodes, curr, n);
    head
}

// Delete first occurrence of val, returns new head
fn delete_val(nodes: Vec<i32>, head: i32, val: i32) -> i32 {
    if head == -1 { return -1; }
    if node_val(nodes, head) == val {
        return node_next(nodes, head);
    }
    var prev = head;
    var curr = node_next(nodes, head);
    while curr != -1 {
        if node_val(nodes, curr) == val {
            set_next(nodes, prev, node_next(nodes, curr));
            return head;
        }
        prev = curr;
        curr = node_next(nodes, curr);
    }
    head
}

// Find: returns index of first node with val, or -1
fn find(nodes: Vec<i32>, head: i32, val: i32) -> i32 {
    var curr = head;
    while curr != -1 {
        if node_val(nodes, curr) == val {
            return curr;
        }
        curr = node_next(nodes, curr);
    }
    -1
}

// Length of list
fn list_len(nodes: Vec<i32>, head: i32) -> i32 {
    var curr = head;
    var count = 0;
    while curr != -1 {
        count = count + 1;
        curr = node_next(nodes, curr);
    }
    count
}

// Collect values into result vec for verification
fn traverse(nodes: Vec<i32>, head: i32, result: Vec<i32>) {
    var curr = head;
    while curr != -1 {
        result.push(node_val(nodes, curr));
        curr = node_next(nodes, curr);
    }
}

fn vecs_equal(a: Vec<i32>, b: Vec<i32>) -> i32 {
    if a.len() != b.len() { return 0; }
    for i in 0..a.len() {
        if a.get(i) != b.get(i) { return 0; }
    }
    1
}

// --- Tests ---

fn test_prepend() -> i32 {
    let nodes: Vec<i32> = Vec::new();
    var head = -1;
    head = prepend(nodes, head, 30);
    head = prepend(nodes, head, 20);
    head = prepend(nodes, head, 10);
    let result: Vec<i32> = Vec::new();
    traverse(nodes, head, result);
    let expected: Vec<i32> = Vec::new();
    expected.push(10); expected.push(20); expected.push(30);
    if vecs_equal(result, expected) == 1 {
        println("PASS: prepend");
        return 1;
    }
    println("FAIL: prepend");
    0
}

fn test_append() -> i32 {
    let nodes: Vec<i32> = Vec::new();
    var head = -1;
    head = append(nodes, head, 10);
    head = append(nodes, head, 20);
    head = append(nodes, head, 30);
    let result: Vec<i32> = Vec::new();
    traverse(nodes, head, result);
    let expected: Vec<i32> = Vec::new();
    expected.push(10); expected.push(20); expected.push(30);
    if vecs_equal(result, expected) == 1 {
        println("PASS: append");
        return 1;
    }
    println("FAIL: append");
    0
}

fn test_delete_middle() -> i32 {
    let nodes: Vec<i32> = Vec::new();
    var head = -1;
    head = append(nodes, head, 10);
    head = append(nodes, head, 20);
    head = append(nodes, head, 30);
    head = delete_val(nodes, head, 20);
    let result: Vec<i32> = Vec::new();
    traverse(nodes, head, result);
    let expected: Vec<i32> = Vec::new();
    expected.push(10); expected.push(30);
    if vecs_equal(result, expected) == 1 {
        println("PASS: delete middle");
        return 1;
    }
    println("FAIL: delete middle");
    0
}

fn test_delete_head() -> i32 {
    let nodes: Vec<i32> = Vec::new();
    var head = -1;
    head = append(nodes, head, 10);
    head = append(nodes, head, 20);
    head = delete_val(nodes, head, 10);
    let result: Vec<i32> = Vec::new();
    traverse(nodes, head, result);
    if result.len() == 1 {
        if result.get(0) == 20 {
            println("PASS: delete head");
            return 1;
        }
    }
    println("FAIL: delete head");
    0
}

fn test_find() -> i32 {
    let nodes: Vec<i32> = Vec::new();
    var head = -1;
    head = append(nodes, head, 10);
    head = append(nodes, head, 20);
    head = append(nodes, head, 30);
    let found = find(nodes, head, 20);
    let not_found = find(nodes, head, 99);
    if found != -1 {
        if node_val(nodes, found) == 20 {
            if not_found == -1 {
                println("PASS: find");
                return 1;
            }
        }
    }
    println("FAIL: find");
    0
}

fn test_length() -> i32 {
    let nodes: Vec<i32> = Vec::new();
    var head = -1;
    if list_len(nodes, head) != 0 {
        println("FAIL: length");
        return 0;
    }
    head = append(nodes, head, 1);
    head = append(nodes, head, 2);
    head = append(nodes, head, 3);
    if list_len(nodes, head) == 3 {
        println("PASS: length");
        return 1;
    }
    println("FAIL: length");
    0
}

fn main() {
    println("=== Singly Linked List Tests ===");
    var passed = 0;
    let total = 6;
    passed = passed + test_prepend();
    passed = passed + test_append();
    passed = passed + test_delete_middle();
    passed = passed + test_delete_head();
    passed = passed + test_find();
    passed = passed + test_length();
    println("");
    print("Passed: ");
    print(passed);
    println(f"/{total}");
    if passed == total {
        println("OVERALL: PASS");
    } else {
        println("OVERALL: FAIL");
    }
}
