// Test: Try (?) Operator
// Exercises: Result<T,E>, Ok/Err construction, ? operator for error propagation,
// chained ? operators, match destructuring of Result values.
fn divide(a: int, b: int) -> Result<int, int> {
    if b == 0 {
        Err(1)
    } else {
        Ok(a / b)
    }
}

// Single ? operator: unwrap Ok or propagate Err
fn try_divide(a: int, b: int) -> Result<int, int> {
    let x = divide(a, b)?;
    Ok(x * 2)
}

// Chained ? operators: both must succeed
fn chain_divide(a: int, b: int, c: int) -> Result<int, int> {
    let x = divide(a, b)?;
    let y = divide(x, c)?;
    Ok(y)
}

fn test_try_ok() -> int {
    let result = try_divide(10, 2);
    match result {
        Ok(v) => {

            // 10 / 2 = 5, * 2 = 10
            if v == 10 {
                println("PASS: ? operator Ok path");
                1
            } else {
                0
            }
        },
        Err(_) => 0,
    }
}

fn test_try_err() -> int {
    let result = try_divide(10, 0);
    match result {
        Ok(_) => 0,
        Err(e) => {
            if e == 1 {
                println("PASS: ? operator Err propagation");
                1
            } else {
                0
            }
        },
    }
}

fn test_chained_ok() -> int {
    // 100 / 5 = 20, 20 / 2 = 10
    let result = chain_divide(100, 5, 2);
    match result {
        Ok(v) => {
            if v == 10 {
                println("PASS: chained ? Ok path");
                1
            } else {
                0
            }
        },
        Err(_) => 0,
    }
}

fn test_chained_first_err() -> int {
    // First divide by 0 â†’ Err(1) propagated
    let result = chain_divide(100, 0, 2);
    match result {
        Ok(_) => 0,
        Err(e) => {
            if e == 1 {
                println("PASS: chained ? first Err");
                1
            } else {
                0
            }
        },
    }
}

fn test_chained_second_err() -> int {
    // 100 / 5 = 20, then divide by 0 â†’ Err(1) propagated
    let result = chain_divide(100, 5, 0);
    match result {
        Ok(_) => 0,
        Err(e) => {
            if e == 1 {
                println("PASS: chained ? second Err");
                1
            } else {
                0
            }
        },
    }
}

fn test_direct_result_ok() -> int {
    let result = divide(10, 2);
    match result {
        Ok(v) => {
            if v == 5 {
                println("PASS: direct Result Ok");
                1
            } else {
                0
            }
        },
        Err(_) => 0,
    }
}

fn test_direct_result_err() -> int {
    let result = divide(10, 0);
    match result {
        Ok(_) => 0,
        Err(e) => {
            if e == 1 {
                println("PASS: direct Result Err");
                1
            } else {
                0
            }
        },
    }
}

fn main() -> int {
    println("=== Test: Try Operator ===");
    var passed = 0;
    let total = 7;
    passed = passed + test_direct_result_ok();
    passed = passed + test_direct_result_err();
    passed = passed + test_try_ok();
    passed = passed + test_try_err();
    passed = passed + test_chained_ok();
    passed = passed + test_chained_first_err();
    passed = passed + test_chained_second_err();
    println("");
    print("Passed: ");
    print(passed);
    println(f"/{total}");
    if passed == total {
        0
    } else {
        1
    }
}
