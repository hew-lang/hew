fn edit_distance(a: Vec<int>, b: Vec<int>, m: int, n: int) -> int {
    let cols = n + 1;
    let total = (m + 1) * cols;
    let dp: Vec<int> = Vec::new();
    var idx = 0;
    while idx < total {
        dp.push(0);
        idx = idx + 1;
    }

    var i = 0;
    while i <= m {
        dp.set(i * cols + 0, i);
        i = i + 1;
    }
    var j = 0;
    while j <= n {
        dp.set(0 * cols + j, j);
        j = j + 1;
    }

    i = 1;
    while i <= m {
        j = 1;
        while j <= n {
            if a.get(i - 1) == b.get(j - 1) {
                dp.set(i * cols + j, dp.get((i - 1) * cols + (j - 1)));
            } else {
                let rep = dp.get((i - 1) * cols + (j - 1)) + 1;
                let del = dp.get((i - 1) * cols + j) + 1;
                let ins = dp.get(i * cols + (j - 1)) + 1;
                var best = rep;
                if del < best {
                    best = del;
                }
                if ins < best {
                    best = ins;
                }
                dp.set(i * cols + j, best);
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return dp.get(m * cols + n);
}

fn main() {
    let m = 50;
    let n = 50;

    let a: Vec<int> = Vec::new();
    let b: Vec<int> = Vec::new();
    var k = 0;
    while k < m {
        a.push(k % 11);
        k = k + 1;
    }
    k = 0;
    while k < n {
        b.push(k % 13);
        k = k + 1;
    }

    let iters = 50000;
    var checksum = 0;
    var i = 0;
    while i < iters {
        checksum = checksum + edit_distance(a, b, m, n);
        i = i + 1;
    }
    println("bench_edit_distance");
    println(checksum);
    println(iters);
}
