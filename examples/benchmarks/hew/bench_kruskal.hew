fn find(parent: Vec<int>, x: int) -> int {
    var r = x;
    while parent.get(r) != r {
        r = parent.get(r);
    }
    var c = x;
    while c != r {
        let next = parent.get(c);
        parent.set(c, r);
        c = next;
    }
    r
}

fn union(parent: Vec<int>, rank: Vec<int>, a: int, b: int) -> int {
    let ra = find(parent, a);
    let rb = find(parent, b);
    if ra == rb {
        return 0;
    }
    if rank.get(ra) < rank.get(rb) {
        parent.set(ra, rb);
    } else {
        if rank.get(ra) > rank.get(rb) {
            parent.set(rb, ra);
        } else {
            parent.set(rb, ra);
            rank.set(ra, rank.get(ra) + 1);
        }
    }
    return 1;
}

fn kruskal(edge_src: Vec<int>, edge_dst: Vec<int>, edge_wt: Vec<int>, sorted_idx: Vec<int>, num_edges: int, n: int) -> int {
    let parent: Vec<int> = Vec::new();
    let rank: Vec<int> = Vec::new();
    for i in 0..n {
        parent.push(i);
        rank.push(0);
    }

    var mst_weight = 0;
    var edges_added = 0;
    var e = 0;
    while e < num_edges {
        if edges_added >= n - 1 {
            e = num_edges;
        } else {
            let idx = sorted_idx.get(e);
            let u = edge_src.get(idx);
            let v = edge_dst.get(idx);
            let w = edge_wt.get(idx);
            let merged = union(parent, rank, u, v);
            if merged == 1 {
                mst_weight = mst_weight + w;
                edges_added = edges_added + 1;
            }
            e = e + 1;
        }
    }
    return mst_weight;
}

fn sort_edges_by_weight(edge_wt: Vec<int>, sorted_idx: Vec<int>, num_edges: int) -> int {
    for i in 0..num_edges {
        sorted_idx.push(i);
    }

    for i in 0..num_edges {
        var j = i + 1;
        while j < num_edges {
            let wi = edge_wt.get(sorted_idx.get(i));
            let wj = edge_wt.get(sorted_idx.get(j));
            if wj < wi {
                let tmp = sorted_idx.get(i);
                sorted_idx.set(i, sorted_idx.get(j));
                sorted_idx.set(j, tmp);
            }
            j = j + 1;
        }
    }
    return 0;
}

const ITERS: int = 100000;

fn main() {
    let n = 50;
    let edge_src: Vec<int> = Vec::new();
    let edge_dst: Vec<int> = Vec::new();
    let edge_wt: Vec<int> = Vec::new();

    for src in 0..n {
        var dst = 1;
        while dst <= 3 {
            let neighbor = (src + dst) % n;
            let weight = (src + dst) % 10 + 1;
            edge_src.push(src);
            edge_dst.push(neighbor);
            edge_wt.push(weight);
            dst = dst + 1;
        }
    }
    let num_edges = edge_src.len();

    let sorted_idx: Vec<int> = Vec::new();
    let _ = sort_edges_by_weight(edge_wt, sorted_idx, num_edges);

    var checksum = 0;
    for i in 0..ITERS {
        checksum = checksum + kruskal(edge_src, edge_dst, edge_wt, sorted_idx, num_edges, n);
    }
    println("bench_kruskal");
    println(checksum);
    println(ITERS);
}
