// Test: Vec Complete
// Exercises all Vec methods comprehensively: new, push, get, set, pop, len, is_empty, String vecs
fn test_vec_push_get() -> int {
    let v: Vec<int> = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);
    let a = v.get(0);
    let b = v.get(1);
    let c = v.get(2);
    if a == 10 {
        if b == 20 {
            if c == 30 {
                println("PASS: test_vec_push_get");
                return 1;
            }
        }
    }
    println("FAIL: test_vec_push_get");
    0
}

fn test_vec_pop() -> int {
    let v: Vec<int> = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    let c = v.pop();
    let b = v.pop();
    let a = v.pop();
    if c == 3 {
        if b == 2 {
            if a == 1 {
                println("PASS: test_vec_pop");
                return 1;
            }
        }
    }
    println("FAIL: test_vec_pop");
    0
}

fn test_vec_len() -> int {
    let v: Vec<int> = Vec::new();
    let len0 = v.len();
    v.push(100);
    v.push(200);
    v.push(300);
    let len3 = v.len();
    v.pop();
    let len2 = v.len();
    if len0 == 0 {
        if len3 == 3 {
            if len2 == 2 {
                println("PASS: test_vec_len");
                return 1;
            }
        }
    }
    println("FAIL: test_vec_len");
    0
}

fn test_vec_set() -> int {
    let v: Vec<int> = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);
    v.set(1, 99);
    let a = v.get(0);
    let b = v.get(1);
    let c = v.get(2);
    if a == 10 {
        if b == 99 {
            if c == 30 {
                println("PASS: test_vec_set");
                return 1;
            }
        }
    }
    println("FAIL: test_vec_set");
    0
}

fn test_vec_is_empty() -> int {
    let v: Vec<int> = Vec::new();
    let empty_before = v.is_empty();
    v.push(42);
    let empty_after = v.is_empty();
    if empty_before {
        if !empty_after {
            println("PASS: test_vec_is_empty");
            return 1;
        }
    }
    println("FAIL: test_vec_is_empty");
    0
}

fn test_vec_string() -> int {
    let v: Vec<String> = Vec::new();
    v.push("hello");
    v.push("world");
    let first = v.get(0);
    let second = v.get(1);
    let len = v.len();
    let first_ok = string_equals(first, "hello");
    let second_ok = string_equals(second, "world");
    if first_ok {
        if second_ok {
            if len == 2 {
                println("PASS: test_vec_string");
                return 1;
            }
        }
    }
    println("FAIL: test_vec_string");
    0
}

fn test_vec_multiple_ops() -> int {
    let v: Vec<int> = Vec::new();
    // Push several values
    var i: int = 0;
    while i < 5 {
        v.push(i * 10);
        i = (i + 1) as int;
    }
    // Verify length after pushes
    let len_after_push = v.len();
    // Set middle element
    v.set(2, 999);
    let middle = v.get(2);
    // Pop last element (40)
    let popped = v.pop();
    let len_after_pop = v.len();
    // Verify first element unchanged
    let first = v.get(0);
    if len_after_push == 5 {
        if middle == 999 {
            if popped == 40 {
                if len_after_pop == 4 {
                    if first == 0 {
                        println("PASS: test_vec_multiple_ops");
                        return 1;
                    }
                }
            }
        }
    }
    println("FAIL: test_vec_multiple_ops");
    0
}

fn main() -> int {
    println("=== Test: Vec Complete ===");
    var passed = 0;
    let total = 7;
    passed = passed + test_vec_push_get();
    passed = passed + test_vec_pop();
    passed = passed + test_vec_len();
    passed = passed + test_vec_set();
    passed = passed + test_vec_is_empty();
    passed = passed + test_vec_string();
    passed = passed + test_vec_multiple_ops();
    println("");
    print("Passed: ");
    println(f"{passed}/{total}");
    if passed == total {
        0
    } else {
        1
    }
}
