// Hash Multimap - One key maps to multiple values
// Uses hash map for key->head_index, linked list nodes in parallel Vecs

fn hash(key: int, capacity: int) -> int {
    let h = key % capacity;
    if h < 0 {
        h + capacity
    } else {
        h
    }
}

// Hash table: maps key -> index into node arrays (head of linked list)
fn make_ht_keys(capacity: int) -> Vec<int> {
    let v: Vec<int> = Vec::new();
    let EMPTY = 0 - 1;
    for i in 0..capacity {
        v.push(EMPTY);
    }
    v
}

fn make_ht_vals(capacity: int) -> Vec<int> {
    let v: Vec<int> = Vec::new();
    let NONE = 0 - 1;
    for i in 0..capacity {
        v.push(NONE);
    }
    v
}

// Find hash table slot for a key
fn ht_find(ht_keys: Vec<int>, key: int) -> int {
    let capacity = ht_keys.len();
    let EMPTY = 0 - 1;
    var idx = hash(key, capacity);
    var i = 0;
    while i < capacity {
        let k = ht_keys.get(idx);
        if k == key {
            return idx;
        }
        if k == EMPTY {
            return idx;
        }
        idx = (idx + 1) % capacity;
        i = i + 1;
    }
    0 - 1
}

// Insert a value for a key into the multimap
// node_vals, node_next are the linked list storage
fn mm_insert(ht_keys: Vec<int>, ht_heads: Vec<int>, node_vals: Vec<int>, node_next: Vec<int>, key: int, value: int) {
    let EMPTY = 0 - 1;
    let NONE = 0 - 1;
    let slot = ht_find(ht_keys, key);
    if slot < 0 {
        return;
    }
    // Allocate a new node
    let new_node = node_vals.len();
    node_vals.push(value);
    node_next.push(NONE);

    let k = ht_keys.get(slot);
    if k == EMPTY {
        // New key
        ht_keys.set(slot, key);
        ht_heads.set(slot, new_node);
    } else {
        // Existing key: prepend to list
        let old_head = ht_heads.get(slot);
        node_next.set(new_node, old_head);
        ht_heads.set(slot, new_node);
    }
}

// Get all values for a key into result Vec, return count
fn mm_get_all(ht_keys: Vec<int>, ht_heads: Vec<int>, node_vals: Vec<int>, node_next: Vec<int>, key: int, result: Vec<int>) -> int {
    let EMPTY = 0 - 1;
    let NONE = 0 - 1;
    let slot = ht_find(ht_keys, key);
    if slot < 0 {
        return 0;
    }
    let k = ht_keys.get(slot);
    if k != key {
        return 0;
    }
    var cur = ht_heads.get(slot);
    var count = 0;
    while cur != NONE {
        result.push(node_vals.get(cur));
        cur = node_next.get(cur);
        count = count + 1;
    }
    count
}

// Remove one occurrence of value for key, return true if found
fn mm_remove_one(ht_keys: Vec<int>, ht_heads: Vec<int>, node_vals: Vec<int>, node_next: Vec<int>, key: int, value: int) -> bool {
    let EMPTY = 0 - 1;
    let NONE = 0 - 1;
    let slot = ht_find(ht_keys, key);
    if slot < 0 {
        return false;
    }
    let k = ht_keys.get(slot);
    if k != key {
        return false;
    }
    // Check head node
    let head = ht_heads.get(slot);
    if head == NONE {
        return false;
    }
    if node_vals.get(head) == value {
        // Remove head
        ht_heads.set(slot, node_next.get(head));
        return true;
    }
    // Search through list
    var prev = head;
    var cur = node_next.get(head);
    while cur != NONE {
        if node_vals.get(cur) == value {
            node_next.set(prev, node_next.get(cur));
            return true;
        }
        prev = cur;
        cur = node_next.get(cur);
    }
    false
}

// Count values for a key
fn mm_count(ht_keys: Vec<int>, ht_heads: Vec<int>, node_next: Vec<int>, key: int) -> int {
    let EMPTY = 0 - 1;
    let NONE = 0 - 1;
    let slot = ht_find(ht_keys, key);
    if slot < 0 {
        return 0;
    }
    let k = ht_keys.get(slot);
    if k != key {
        return 0;
    }
    var cur = ht_heads.get(slot);
    var count = 0;
    while cur != NONE {
        count = count + 1;
        cur = node_next.get(cur);
    }
    count
}

fn vec_contains(v: Vec<int>, val: int) -> bool {
    let len = v.len();
    for i in 0..len {
        if v.get(i) == val {
            return true;
        }
    }
    false
}

fn main() {
    var passed = 0;
    var failed = 0;
    let cap = 32;
    let ht_keys = make_ht_keys(cap);
    let ht_heads = make_ht_vals(cap);
    let node_vals: Vec<int> = Vec::new();
    let node_next: Vec<int> = Vec::new();

    // Test 1: Insert multiple values for same key
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 1, 10);
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 1, 20);
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 1, 30);
    let c1 = mm_count(ht_keys, ht_heads, node_next, 1);
    if c1 == 3 {
        println("PASS: insert multiple values");
        passed = passed + 1;
    } else {
        println("FAIL: insert multiple values");
        failed = failed + 1;
    }

    // Test 2: Get all values for a key
    let r1: Vec<int> = Vec::new();
    let gc1 = mm_get_all(ht_keys, ht_heads, node_vals, node_next, 1, r1);
    if gc1 == 3 {
        if vec_contains(r1, 10) {
            if vec_contains(r1, 20) {
                if vec_contains(r1, 30) {
                    println("PASS: get all values");
                    passed = passed + 1;
                } else {
                    println("FAIL: get all values");
                    failed = failed + 1;
                }
            } else {
                println("FAIL: get all values");
                failed = failed + 1;
            }
        } else {
            println("FAIL: get all values");
            failed = failed + 1;
        }
    } else {
        println("FAIL: get all values");
        failed = failed + 1;
    }

    // Test 3: Different keys have separate value lists
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 2, 100);
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 2, 200);
    let c2 = mm_count(ht_keys, ht_heads, node_next, 2);
    if c2 == 2 {
        let c1b = mm_count(ht_keys, ht_heads, node_next, 1);
        if c1b == 3 {
            println("PASS: separate key lists");
            passed = passed + 1;
        } else {
            println("FAIL: separate key lists");
            failed = failed + 1;
        }
    } else {
        println("FAIL: separate key lists");
        failed = failed + 1;
    }

    // Test 4: Remove one value
    let removed = mm_remove_one(ht_keys, ht_heads, node_vals, node_next, 1, 20);
    if removed {
        let c1c = mm_count(ht_keys, ht_heads, node_next, 1);
        if c1c == 2 {
            println("PASS: remove one value");
            passed = passed + 1;
        } else {
            print("FAIL: remove one value, count=");
            println(c1c);
            failed = failed + 1;
        }
    } else {
        println("FAIL: remove one value");
        failed = failed + 1;
    }

    // Test 5: Removed value no longer in list
    let r2: Vec<int> = Vec::new();
    let _ = mm_get_all(ht_keys, ht_heads, node_vals, node_next, 1, r2);
    if vec_contains(r2, 20) {
        println("FAIL: removed value still present");
        failed = failed + 1;
    } else {
        if vec_contains(r2, 10) {
            if vec_contains(r2, 30) {
                println("PASS: removed value absent");
                passed = passed + 1;
            } else {
                println("FAIL: remaining values");
                failed = failed + 1;
            }
        } else {
            println("FAIL: remaining values");
            failed = failed + 1;
        }
    }

    // Test 6: Remove non-existent value returns false
    let rem2 = mm_remove_one(ht_keys, ht_heads, node_vals, node_next, 1, 999);
    if rem2 {
        println("FAIL: remove non-existent");
        failed = failed + 1;
    } else {
        println("PASS: remove non-existent");
        passed = passed + 1;
    }

    // Test 7: Count for non-existent key
    let cn = mm_count(ht_keys, ht_heads, node_next, 999);
    if cn == 0 {
        println("PASS: count non-existent key");
        passed = passed + 1;
    } else {
        println("FAIL: count non-existent key");
        failed = failed + 1;
    }

    // Test 8: Duplicate values allowed
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 3, 50);
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 3, 50);
    mm_insert(ht_keys, ht_heads, node_vals, node_next, 3, 50);
    let c3 = mm_count(ht_keys, ht_heads, node_next, 3);
    if c3 == 3 {
        println("PASS: duplicate values allowed");
        passed = passed + 1;
    } else {
        println("FAIL: duplicate values allowed");
        failed = failed + 1;
    }

    // Summary
    println("---");
    print("Passed: ");
    println(passed);
    print("Failed: ");
    println(failed);
    if failed == 0 {
        println("ALL PASS");
    } else {
        println("SOME FAILED");
    }
}
