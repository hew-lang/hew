// 2x2 matrix multiply using flat Vec<i32> (row-major order)
// C[i][j] = sum(A[i][k] * B[k][j]) for k in 0..n

fn mat_mul(a: Vec<i32>, b: Vec<i32>, n: i32) -> Vec<i32> {
    let c: Vec<i32> = Vec::new();
    for i in 0..n {
        for j in 0..n {
            var sum = 0;
            for k in 0..n {
                sum = sum + a.get(i * n + k) * b.get(k * n + j);
            }
            c.push(sum);
        }
    }
    c
}

fn main() {
    // A = [[1,2],[3,4]], B = [[5,6],[7,8]]
    // C = [[1*5+2*7, 1*6+2*8], [3*5+4*7, 3*6+4*8]] = [[19,22],[43,50]]
    let a: Vec<i32> = Vec::new();
    a.push(1); a.push(2); a.push(3); a.push(4);

    let b: Vec<i32> = Vec::new();
    b.push(5); b.push(6); b.push(7); b.push(8);

    let c = mat_mul(a, b, 2);

    var pass = true;
    if c.get(0) != 19 { pass = false; println("FAIL [0,0]"); println(c.get(0)); }
    if c.get(1) != 22 { pass = false; println("FAIL [0,1]"); println(c.get(1)); }
    if c.get(2) != 43 { pass = false; println("FAIL [1,0]"); println(c.get(2)); }
    if c.get(3) != 50 { pass = false; println("FAIL [1,1]"); println(c.get(3)); }

    // Test 2: identity * A = A
    let id: Vec<i32> = Vec::new();
    id.push(1); id.push(0); id.push(0); id.push(1);

    let a2: Vec<i32> = Vec::new();
    a2.push(3); a2.push(7); a2.push(2); a2.push(5);

    let r = mat_mul(id, a2, 2);
    if r.get(0) != 3 { pass = false; println("FAIL id[0]"); }
    if r.get(1) != 7 { pass = false; println("FAIL id[1]"); }
    if r.get(2) != 2 { pass = false; println("FAIL id[2]"); }
    if r.get(3) != 5 { pass = false; println("FAIL id[3]"); }

    if pass {
        println("PASS");
    } else {
        println("FAIL");
    }
}
