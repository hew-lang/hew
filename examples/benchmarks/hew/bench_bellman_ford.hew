fn bellman_ford(edge_src: Vec<int>, edge_dst: Vec<int>, edge_wt: Vec<int>, num_edges: int, n: int, start_node: int) -> int {
    let INF = 999999;
    let dist: Vec<int> = Vec::new();
    for i in 0..n {
        dist.push(INF);
    }
    dist.set(start_node, 0);

    for iter in 0..(n - 1) {
        for e in 0..num_edges {
            let u = edge_src.get(e);
            let v = edge_dst.get(e);
            let w = edge_wt.get(e);
            let nd = dist.get(u) + w;
            if dist.get(u) < INF {
                if nd < dist.get(v) {
                    dist.set(v, nd);
                }
            }
        }
    }

    var total = 0;
    for i in 0..n {
        total = total + dist.get(i);
    }
    return total;
}

fn main() {
    let n = 50;
    let edge_src: Vec<int> = Vec::new();
    let edge_dst: Vec<int> = Vec::new();
    let edge_wt: Vec<int> = Vec::new();

    for src in 0..n {
        for dst in 1..4 {
            let neighbor = (src + dst) % n;
            let weight = (src + dst) % 10 + 1;
            edge_src.push(src);
            edge_dst.push(neighbor);
            edge_wt.push(weight);
        }
    }
    let num_edges = edge_src.len();

    let iters = 20000;
    var checksum = 0;
    for i in 0..iters {
        checksum = checksum + bellman_ford(edge_src, edge_dst, edge_wt, num_edges, n, 0);
    }
    println("bench_bellman_ford");
    println(checksum);
    println(iters);
}
