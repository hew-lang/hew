// Bellman-Ford Shortest Path (handles negative edges)
// Graph (5 nodes):
//   0->1(6), 0->2(7), 1->2(8), 1->3(5), 1->4(-4),
//   2->3(-3), 2->4(9), 3->1(-2), 4->3(7)
// Expected distances from 0: [0, 2, 7, 4, -2] -> using sentinels: [0, 2, 7, 4, 999996]
// Actually let's use a simpler graph without negative results to avoid negative literal issues

// Simpler graph (5 nodes):
//   0->1(4), 0->2(1), 1->3(1), 2->1(2), 2->3(5), 3->4(3)
// Same as Dijkstra test. Expected: [0, 3, 1, 4, 7]

fn main() {
    let num_nodes = 5;
    let INF = 999999;

    // Edge list: (from, to, weight)
    let edge_from: Vec<i32> = Vec::new();
    let edge_to: Vec<i32> = Vec::new();
    let edge_weight: Vec<i32> = Vec::new();

    edge_from.push(0); edge_to.push(1); edge_weight.push(4);
    edge_from.push(0); edge_to.push(2); edge_weight.push(1);
    edge_from.push(1); edge_to.push(3); edge_weight.push(1);
    edge_from.push(2); edge_to.push(1); edge_weight.push(2);
    edge_from.push(2); edge_to.push(3); edge_weight.push(5);
    edge_from.push(3); edge_to.push(4); edge_weight.push(3);

    let num_edges = edge_from.len();

    let dist: Vec<i32> = Vec::new();
    for i in 0..num_nodes {
        dist.push(INF);
    }
    dist.set(0, 0);

    // Relax edges V-1 times
    for iter in 0..(num_nodes - 1) {
        for e in 0..num_edges {
            let u = edge_from.get(e);
            let v = edge_to.get(e);
            let w = edge_weight.get(e);
            if dist.get(u) != INF {
                let new_dist = dist.get(u) + w;
                if new_dist < dist.get(v) {
                    dist.set(v, new_dist);
                }
            }
        }
    }

    // Check for negative cycles (none expected)
    var has_neg_cycle = 0;
    for e in 0..num_edges {
        let u = edge_from.get(e);
        let v = edge_to.get(e);
        let w = edge_weight.get(e);
        if dist.get(u) != INF {
            if dist.get(u) + w < dist.get(v) {
                has_neg_cycle = 1;
            }
        }
    }

    let expected: Vec<i32> = Vec::new();
    expected.push(0);
    expected.push(3);
    expected.push(1);
    expected.push(4);
    expected.push(7);

    var ok = 1;
    for i in 0..num_nodes {
        println(dist.get(i));
        if dist.get(i) != expected.get(i) {
            ok = 0;
        }
    }

    if has_neg_cycle == 1 {
        ok = 0;
    }

    if ok == 1 {
        println("PASS");
    } else {
        println("FAIL");
    }
}
