// Benchmark: Ternary Search
// Divides search space into three parts instead of two.

fn ternary_search(v: Vec<int>, target: int) -> int {
    var lo = 0;
    var hi = v.len() - 1;
    while lo <= hi {
        let third = (hi - lo) / 3;
        let mid1 = lo + third;
        let mid2 = hi - third;
        let val1 = v.get(mid1);
        let val2 = v.get(mid2);
        if val1 == target {
            return mid1;
        }
        if val2 == target {
            return mid2;
        }
        if target < val1 {
            hi = mid1 - 1;
        } else {
            if target > val2 {
                lo = mid2 + 1;
            } else {
                lo = mid1 + 1;
                hi = mid2 - 1;
            }
        }
    }
    return 0 - 1;
}

fn main() {
    let v: Vec<int> = Vec::new();
    var i = 0;
    while i < 10000 {
        v.push(i);
        i = i + 1;
    }
    let iters = 1000000;
    var iter = 0;
    var sum = 0;
    while iter < iters {
        sum = sum + ternary_search(v, 7777);
        iter = iter + 1;
    }
    println(iters);
    println(sum);
}
