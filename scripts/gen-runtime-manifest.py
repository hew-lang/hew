#!/usr/bin/env python3
"""Generate hew-codegen/runtime_manifest.json from hew-runtime/src/*.rs.

Scans all Rust source files for `#[no_mangle] pub ... extern "C" fn` signatures
and produces a JSON manifest that the compiler can use to resolve stdlib calls.
"""

import json
import re
import sys
from pathlib import Path

RUNTIME_DIR = Path(__file__).resolve().parent.parent / "hew-runtime" / "src"
OUTPUT_FILE = Path(__file__).resolve().parent.parent / "hew-codegen" / "runtime_manifest.json"

# Map Rust types to C ABI types used by the compiler
RUST_TO_C_TYPE = {
    "i8": "i8",
    "i16": "i16",
    "i32": "i32",
    "i64": "i64",
    "u8": "u8",
    "u16": "u16",
    "u32": "u32",
    "u64": "u64",
    "usize": "u64",
    "isize": "i64",
    "f32": "f32",
    "f64": "f64",
    "bool": "i1",
    "*const c_char": "ptr",
    "*mut c_char": "ptr",
    "*const u8": "ptr",
    "*mut u8": "ptr",
    "*const c_void": "ptr",
    "*mut c_void": "ptr",
    "c_int": "i32",
    "c_uint": "u32",
}

# Internal-only modules not useful for user-facing stdlib imports
INTERNAL_MODULES = {
    "scheduler", "mailbox", "node", "transport", "wire",
    "reply_channel", "task_scope", "blocking_pool", "timer_wheel",
    "scope", "internal",
}


def normalize_type(rust_type: str) -> str:
    """Convert a Rust type annotation to a C ABI type string."""
    t = rust_type.strip()
    if t in RUST_TO_C_TYPE:
        return RUST_TO_C_TYPE[t]
    # Pointer to any named type
    if t.startswith("*const ") or t.startswith("*mut "):
        return "ptr"
    return "ptr"  # opaque pointer fallback for unknown types


def extract_functions(source: str) -> list[dict]:
    """Extract all #[no_mangle] extern "C" fn signatures from Rust source."""
    results = []

    # Find each #[no_mangle] attribute, then look forward for the fn signature.
    for m in re.finditer(r'#\[no_mangle\]', source):
        start = m.end()
        # Look ahead up to 500 chars for the fn signature (handles interleaved attrs)
        window = source[start:start + 500]
        fn_match = re.match(
            r'(?:\s*#\[[^\]]*(?:\([^)]*\))?[^\]]*\])*'  # skip other attributes
            r'\s*(?:pub\s+)?(?:unsafe\s+)?extern\s+"C"\s+fn\s+'
            r'(\w+)\s*\(((?:[^()]*|\([^()]*\))*)\)\s*(?:->\s*([^{]+?))?\s*\{',
            window,
            re.DOTALL,
        )
        if not fn_match:
            continue

        fn_name = fn_match.group(1)
        raw_params = fn_match.group(2).strip()
        raw_return = fn_match.group(3)

        params = []
        if raw_params:
            for p in raw_params.split(","):
                p = p.strip()
                if not p:
                    continue
                if ":" in p:
                    pname, ptype = p.split(":", 1)
                    params.append({
                        "name": pname.strip(),
                        "type": normalize_type(ptype.strip()),
                    })

        ret = "void"
        if raw_return:
            ret = normalize_type(raw_return.strip())

        results.append({
            "name": fn_name,
            "params": params,
            "returns": ret,
        })

    return results


def main():
    if not RUNTIME_DIR.is_dir():
        print(f"Error: runtime directory not found: {RUNTIME_DIR}", file=sys.stderr)
        sys.exit(1)

    modules = {}
    total_fns = 0

    for rs_file in sorted(RUNTIME_DIR.glob("*.rs")):
        mod_name = rs_file.stem
        if mod_name == "lib" or mod_name in INTERNAL_MODULES:
            continue

        source = rs_file.read_text()
        if "#[no_mangle]" not in source:
            continue

        fns = extract_functions(source)
        if fns:
            modules[mod_name] = {"functions": fns}
            total_fns += len(fns)

    manifest = {
        "_comment": "Auto-generated by scripts/gen-runtime-manifest.py. Do not edit.",
        "_usage": (
            "The hew-codegen compiler reads this manifest to resolve stdlib function calls. "
            "When a .hew file calls e.g. json::parse(), the compiler looks up "
            "hew_json_parse in this manifest and generates an MLIR func.func "
            "declaration with the matching C ABI signature."
        ),
        "version": "0.1.0",
        "total_functions": total_fns,
        "modules": modules,
    }

    OUTPUT_FILE.write_text(json.dumps(manifest, indent=2) + "\n")
    print(f"Generated {OUTPUT_FILE} with {total_fns} functions across {len(modules)} modules.")


if __name__ == "__main__":
    main()
