// Cycle Detection in Directed Graph using DFS coloring
// Colors: 0=white (unvisited), 1=gray (in progress), 2=black (done)
// Test 1: graph WITH cycle (0->1->2->0) -> has cycle
// Test 2: DAG without cycle (0->1->2, 0->2) -> no cycle

fn main() {
    // --- Test 1: graph with cycle ---
    // 3 nodes: 0->1, 1->2, 2->0
    let adj1_nodes: Vec<i32> = Vec::new();
    let adj1_offsets: Vec<i32> = Vec::new();

    adj1_offsets.push(0);
    adj1_nodes.push(1);
    adj1_offsets.push(1);
    adj1_nodes.push(2);
    adj1_offsets.push(2);
    adj1_nodes.push(0);
    adj1_offsets.push(3);

    let n1 = 3;
    let color1: Vec<i32> = Vec::new();
    for i in 0..n1 {
        color1.push(0);
    }

    // Iterative DFS with explicit stack for cycle detection
    // Stack entries: node * 2 + phase (0 = enter, 1 = exit)
    var has_cycle1 = 0;
    for start in 0..n1 {
        if color1.get(start) == 0 {
            let stack: Vec<i32> = Vec::new();
            stack.push(start * 2);
            while stack.len() > 0 {
                let entry = stack.pop();
                let node = entry / 2;
                let phase = entry % 2;
                if phase == 1 {
                    color1.set(node, 2);
                } else {
                    if color1.get(node) == 2 {
                        // already done
                    } else {
                        if color1.get(node) == 1 {
                            // already gray, skip
                        } else {
                            color1.set(node, 1);
                            stack.push(node * 2 + 1);
                            let s = adj1_offsets.get(node);
                            let e = adj1_offsets.get(node + 1);
                            var idx = s;
                            while idx < e {
                                let v = adj1_nodes.get(idx);
                                if color1.get(v) == 1 {
                                    has_cycle1 = 1;
                                } else {
                                    if color1.get(v) == 0 {
                                        stack.push(v * 2);
                                    }
                                }
                                idx = idx + 1;
                            }
                        }
                    }
                }
            }
        }
    }

    // --- Test 2: DAG without cycle ---
    // 3 nodes: 0->1, 0->2, 1->2
    let adj2_nodes: Vec<i32> = Vec::new();
    let adj2_offsets: Vec<i32> = Vec::new();

    adj2_offsets.push(0);
    adj2_nodes.push(1);
    adj2_nodes.push(2);
    adj2_offsets.push(2);
    adj2_nodes.push(2);
    adj2_offsets.push(3);
    adj2_offsets.push(3);

    let n2 = 3;
    let color2: Vec<i32> = Vec::new();
    for i in 0..n2 {
        color2.push(0);
    }

    var has_cycle2 = 0;
    for start in 0..n2 {
        if color2.get(start) == 0 {
            let stack: Vec<i32> = Vec::new();
            stack.push(start * 2);
            while stack.len() > 0 {
                let entry = stack.pop();
                let node = entry / 2;
                let phase = entry % 2;
                if phase == 1 {
                    color2.set(node, 2);
                } else {
                    if color2.get(node) == 2 {
                        // done
                    } else {
                        if color2.get(node) == 1 {
                            // skip
                        } else {
                            color2.set(node, 1);
                            stack.push(node * 2 + 1);
                            let s = adj2_offsets.get(node);
                            let e = adj2_offsets.get(node + 1);
                            var idx = s;
                            while idx < e {
                                let v = adj2_nodes.get(idx);
                                if color2.get(v) == 1 {
                                    has_cycle2 = 1;
                                } else {
                                    if color2.get(v) == 0 {
                                        stack.push(v * 2);
                                    }
                                }
                                idx = idx + 1;
                            }
                        }
                    }
                }
            }
        }
    }

    var ok = 1;
    if has_cycle1 != 1 {
        ok = 0;
    }
    if has_cycle2 != 0 {
        ok = 0;
    }

    println(has_cycle1);
    println(has_cycle2);
    if ok == 1 {
        println("PASS");
    } else {
        println("FAIL");
    }
}
