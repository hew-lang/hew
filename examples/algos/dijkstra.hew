// Dijkstra's Shortest Path
// Weighted graph (5 nodes):
//   0->1(4), 0->2(1), 1->3(1), 2->1(2), 2->3(5), 3->4(3)
// Expected distances from 0: [0, 3, 1, 4, 7]

fn main() {
    let num_nodes = 5;
    let INF = 999999;

    // Weighted adjacency list
    let adj_nodes: Vec<i32> = Vec::new();
    let adj_weights: Vec<i32> = Vec::new();
    let adj_offsets: Vec<i32> = Vec::new();

    // Node 0: -> 1(4), 2(1)
    adj_offsets.push(0);
    adj_nodes.push(1);
    adj_weights.push(4);
    adj_nodes.push(2);
    adj_weights.push(1);
    // Node 1: -> 3(1)
    adj_offsets.push(2);
    adj_nodes.push(3);
    adj_weights.push(1);
    // Node 2: -> 1(2), 3(5)
    adj_offsets.push(3);
    adj_nodes.push(1);
    adj_weights.push(2);
    adj_nodes.push(3);
    adj_weights.push(5);
    // Node 3: -> 4(3)
    adj_offsets.push(5);
    adj_nodes.push(4);
    adj_weights.push(3);
    // Node 4: (no outgoing)
    adj_offsets.push(6);
    adj_offsets.push(6);

    // Dijkstra using simple O(V^2) approach
    let dist: Vec<i32> = Vec::new();
    let visited: Vec<i32> = Vec::new();
    for i in 0..num_nodes {
        dist.push(INF);
        visited.push(0);
    }
    dist.set(0, 0);

    for iter in 0..num_nodes {
        // Find unvisited node with minimum distance
        var u = 0 - 1;
        var min_dist = INF;
        for i in 0..num_nodes {
            if visited.get(i) == 0 {
                if dist.get(i) < min_dist {
                    min_dist = dist.get(i);
                    u = i;
                }
            }
        }

        if u == 0 - 1 {
            // No more reachable nodes - use while+break alternative
        } else {
            visited.set(u, 1);
            let start = adj_offsets.get(u);
            let end = adj_offsets.get(u + 1);
            var idx = start;
            while idx < end {
                let v = adj_nodes.get(idx);
                let w = adj_weights.get(idx);
                let new_dist = dist.get(u) + w;
                if new_dist < dist.get(v) {
                    dist.set(v, new_dist);
                }
                idx = idx + 1;
            }
        }
    }

    // Expected: [0, 3, 1, 4, 7]
    let expected: Vec<i32> = Vec::new();
    expected.push(0);
    expected.push(3);
    expected.push(1);
    expected.push(4);
    expected.push(7);

    var ok = 1;
    for i in 0..num_nodes {
        println(dist.get(i));
        if dist.get(i) != expected.get(i) {
            ok = 0;
        }
    }

    if ok == 1 {
        println("PASS");
    } else {
        println("FAIL");
    }
}
