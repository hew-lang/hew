// Adjacency Matrix - Flat n*n Vec<int> representation
// matrix[i*n + j] = 1 if edge (i,j) exists, 0 otherwise

fn mat_get(matrix: Vec<int>, n: int, i: int, j: int) -> int {
    matrix.get(i * n + j)
}

fn mat_set(matrix: Vec<int>, n: int, i: int, j: int, val: int) {
    matrix.set(i * n + j, val);
}

fn add_edge(matrix: Vec<int>, n: int, u: int, v: int) {
    mat_set(matrix, n, u, v, 1);
    mat_set(matrix, n, v, u, 1);
}

fn remove_edge(matrix: Vec<int>, n: int, u: int, v: int) {
    mat_set(matrix, n, u, v, 0);
    mat_set(matrix, n, v, u, 0);
}

fn has_edge(matrix: Vec<int>, n: int, u: int, v: int) -> bool {
    mat_get(matrix, n, u, v) == 1
}

fn degree(matrix: Vec<int>, n: int, node: int) -> int {
    var d = 0;
    for j in 0..n {
        if mat_get(matrix, n, node, j) == 1 {
            d = d + 1;
        }
    }
    d
}

fn is_symmetric(matrix: Vec<int>, n: int) -> bool {
    for i in 0..n {
        for j in 0..n {
            if mat_get(matrix, n, i, j) != mat_get(matrix, n, j, i) {
                return false;
            }
        }
    }
    true
}

fn main() {
    var passed = 0;
    var failed = 0;
    let n = 6;

    // Initialize n*n matrix to 0
    let matrix: Vec<int> = Vec::new();
    for i in 0..(n * n) {
        matrix.push(0);
    }

    // Build graph: (0,1),(0,2),(1,2),(1,3),(2,4),(3,4),(3,5),(4,5)
    add_edge(matrix, n, 0, 1);
    add_edge(matrix, n, 0, 2);
    add_edge(matrix, n, 1, 2);
    add_edge(matrix, n, 1, 3);
    add_edge(matrix, n, 2, 4);
    add_edge(matrix, n, 3, 4);
    add_edge(matrix, n, 3, 5);
    add_edge(matrix, n, 4, 5);

    // Test 1: Edge existence
    if has_edge(matrix, n, 0, 1) {
        if has_edge(matrix, n, 3, 5) {
            println("PASS: edges exist");
            passed = passed + 1;
        } else {
            println("FAIL: edges exist");
            failed = failed + 1;
        }
    } else {
        println("FAIL: edges exist");
        failed = failed + 1;
    }

    // Test 2: Non-edge
    if has_edge(matrix, n, 0, 5) {
        println("FAIL: non-edge (0,5)");
        failed = failed + 1;
    } else {
        println("PASS: non-edge (0,5)");
        passed = passed + 1;
    }

    // Test 3: Symmetry
    if is_symmetric(matrix, n) {
        println("PASS: matrix is symmetric");
        passed = passed + 1;
    } else {
        println("FAIL: matrix symmetry");
        failed = failed + 1;
    }

    // Test 4: Degree of node 1 = 3
    if degree(matrix, n, 1) == 3 {
        println("PASS: degree(1) = 3");
        passed = passed + 1;
    } else {
        println("FAIL: degree(1)");
        failed = failed + 1;
    }

    // Test 5: Degree of node 0 = 2
    if degree(matrix, n, 0) == 2 {
        println("PASS: degree(0) = 2");
        passed = passed + 1;
    } else {
        println("FAIL: degree(0)");
        failed = failed + 1;
    }

    // Test 6: Remove edge (1,2), verify gone
    remove_edge(matrix, n, 1, 2);
    if has_edge(matrix, n, 1, 2) {
        println("FAIL: edge (1,2) not removed");
        failed = failed + 1;
    } else {
        if has_edge(matrix, n, 2, 1) {
            println("FAIL: edge (2,1) not removed");
            failed = failed + 1;
        } else {
            println("PASS: edge (1,2) removed");
            passed = passed + 1;
        }
    }

    // Test 7: Degree after removal
    if degree(matrix, n, 1) == 2 {
        println("PASS: degree(1) = 2 after removal");
        passed = passed + 1;
    } else {
        println("FAIL: degree(1) after removal");
        failed = failed + 1;
    }

    // Test 8: Still symmetric after removal
    if is_symmetric(matrix, n) {
        println("PASS: still symmetric after removal");
        passed = passed + 1;
    } else {
        println("FAIL: symmetry after removal");
        failed = failed + 1;
    }

    println("---");
    print("Passed: ");
    print(passed);
    print("/");
    println(8);
    if failed == 0 {
        println("ALL PASS");
    } else {
        println("SOME FAILED");
    }
}
